;; -*- Gerbil -*-
;;;; AWK String Built-in Functions

(import ../value ../runtime ../ast :gerbil-pcre/pcre2/pcre2 :std/srfi/13)
(export #t)

;;; length([s])
(def (awk-builtin-length env args)
  (if (null? args)
    (make-awk-number (string-length (awk->string (env-get-field env 0))))
    (let ((v (car args)))
      (make-awk-number (string-length (awk->string v))))))

;;; substr(s, start [, len])
(def (awk-builtin-substr env args)
  (let* ((str (awk->string (car args)))
         (slen (string-length str))
         (pos (inexact->exact (floor (awk->number (cadr args)))))
         (pos (max 1 pos))
         (maxlen (if (> (length args) 2)
                   (inexact->exact (floor (awk->number (caddr args))))
                   (+ slen 1))))
    (if (> pos slen)
      (make-awk-string "")
      (let* ((start (- pos 1))
             (end (min (+ start maxlen) slen)))
        (make-awk-string (substring str start end))))))

;;; index(s, t)
(def (awk-builtin-index env args)
  (let* ((str (awk->string (car args)))
         (target (awk->string (cadr args)))
         (pos (string-contains str target)))
    (make-awk-number (if pos (+ pos 1) 0))))

;;; split(s, a [, fs])
(def (awk-builtin-split env args)
  (let* ((str (awk->string (car args)))
         (arr-name (cadr args)) ;; this is an awk-expr-var passed by reference
         (fs (if (> (length args) 2)
               (awk->string (caddr args))
               (env-get-str env 'FS)))
         (parts (cond
                  ((string=? fs " ") (split-on-whitespace str))
                  ((string=? fs "") (map string (string->list str)))
                  ((= (string-length fs) 1) (split-on-char str (string-ref fs 0)))
                  (else (pcre2-split fs str))))
         (arr (env-get-array env arr-name)))
    ;; Clear array
    (hash-clear! arr)
    ;; Populate 1-indexed
    (let loop ((i 1) (parts parts))
      (unless (null? parts)
        (hash-put! arr (number->string i) (make-awk-strnum (car parts)))
        (loop (+ i 1) (cdr parts))))
    (make-awk-number (length parts))))

;;; sub(re, repl [, target])  — returns count of replacements (0 or 1)
(def (awk-builtin-sub env args ere repl-str target-expr set-target!)
  (let* ((pattern (if (awk-expr-regex? ere)
                    (awk-expr-regex-pattern ere)
                    (awk->string ere)))
         (target-str (awk->string target-expr))
         (m (pcre2-search pattern target-str)))
    (if m
      (let* ((pos (pcre-match-positions m 0))
             (start (car pos))
             (end (cdr pos))
             (replacement (build-replacement repl-str pos target-str))
             (result (string-append (substring target-str 0 start)
                                    replacement
                                    (substring target-str end (string-length target-str)))))
        (set-target! (make-awk-string result))
        (make-awk-number 1))
      (make-awk-number 0))))

;;; gsub(re, repl [, target])  — returns count of replacements
(def (awk-builtin-gsub env args ere repl-str target-expr set-target!)
  (let* ((pattern (if (awk-expr-regex? ere)
                    (awk-expr-regex-pattern ere)
                    (awk->string ere)))
         (target-str (awk->string target-expr))
         (count 0))
    (let loop ((pos 0) (result '()))
      (let ((m (pcre2-search pattern target-str pos)))
        (if (not m)
          (let ((final (string-append (apply string-append (reverse result))
                                      (substring target-str pos (string-length target-str)))))
            (set-target! (make-awk-string final))
            (make-awk-number count))
          (let* ((mpos (pcre-match-positions m 0))
                 (start (car mpos))
                 (end (cdr mpos))
                 (replacement (build-replacement repl-str mpos target-str)))
            (set! count (+ count 1))
            (loop (if (= start end) (+ end 1) end)
                  (cons replacement
                        (cons (substring target-str pos start) result)))))))))

(def (build-replacement repl-str match-pair target-str)
  "Process replacement string: & = matched text, \\ = literal backslash"
  (let ((mstart (car match-pair))
        (mend (cdr match-pair))
        (rlen (string-length repl-str)))
    (let loop ((i 0) (chars '()))
      (if (>= i rlen)
        (list->string (reverse chars))
        (let ((c (string-ref repl-str i)))
          (cond
            ((char=? c #\\)
             (if (< (+ i 1) rlen)
               (let ((next (string-ref repl-str (+ i 1))))
                 (if (char=? next #\&)
                   (loop (+ i 2) (cons #\& chars))
                   (if (char=? next #\\)
                     (loop (+ i 2) (cons #\\ chars))
                     (loop (+ i 2) (cons next (cons #\\ chars))))))
               (loop (+ i 1) (cons #\\ chars))))
            ((char=? c #\&)
             (let ((matched (substring target-str mstart mend)))
               (loop (+ i 1)
                     (append (reverse (string->list matched)) chars))))
            (else
             (loop (+ i 1) (cons c chars)))))))))

;;; match(s, re)
(def (awk-builtin-match env args)
  (let* ((str (awk->string (car args)))
         (pattern (let ((p (cadr args)))
                    (if (awk-expr-regex? p)
                      (awk-expr-regex-pattern p)
                      (awk->string p))))
         (m (pcre2-search pattern str)))
    (if m
      (let* ((pos (pcre-match-positions m 0))
             (start (car pos))
             (end (cdr pos)))
        (env-set! env 'RSTART (make-awk-number (+ start 1)))
        (env-set! env 'RLENGTH (make-awk-number (- end start)))
        (make-awk-number (+ start 1)))
      (begin
        (env-set! env 'RSTART (make-awk-number 0))
        (env-set! env 'RLENGTH (make-awk-number -1))
        (make-awk-number 0)))))

;;; sprintf(fmt, ...)
(def (awk-builtin-sprintf env args)
  (let ((fmt (awk->string (car args)))
        (vals (cdr args)))
    (make-awk-string (awk-sprintf fmt vals))))

;;; tolower(s)
(def (awk-builtin-tolower env args)
  (make-awk-string (string-downcase (awk->string (car args)))))

;;; toupper(s)
(def (awk-builtin-toupper env args)
  (make-awk-string (string-upcase (awk->string (car args)))))

;;; Printf/Sprintf formatting engine

(def (awk-sprintf fmt args)
  "Format string using AWK printf rules"
  (let ((flen (string-length fmt)))
    (let loop ((i 0) (args args) (out '()))
      (if (>= i flen)
        (list->string (reverse out))
        (let ((c (string-ref fmt i)))
          (if (char=? c #\\)
            ;; Escape sequence
            (if (< (+ i 1) flen)
              (let ((next (string-ref fmt (+ i 1))))
                (case next
                  ((#\n) (loop (+ i 2) args (cons #\newline out)))
                  ((#\t) (loop (+ i 2) args (cons #\tab out)))
                  ((#\r) (loop (+ i 2) args (cons #\return out)))
                  ((#\\) (loop (+ i 2) args (cons #\\ out)))
                  ((#\a) (loop (+ i 2) args (cons #\alarm out)))
                  ((#\b) (loop (+ i 2) args (cons #\backspace out)))
                  ((#\f) (loop (+ i 2) args (cons #\page out)))
                  ((#\v) (loop (+ i 2) args (cons #\vtab out)))
                  ((#\") (loop (+ i 2) args (cons #\" out)))
                  ((#\/) (loop (+ i 2) args (cons #\/ out)))
                  (else (loop (+ i 2) args (cons next out)))))
              (loop (+ i 1) args (cons #\\ out)))
            (if (char=? c #\%)
              (if (and (< (+ i 1) flen) (char=? (string-ref fmt (+ i 1)) #\%))
                (loop (+ i 2) args (cons #\% out))
                (let-values (((formatted new-i new-args) (format-one-spec fmt i args)))
                  (loop new-i new-args
                        (append (reverse (string->list formatted)) out))))
              (loop (+ i 1) args (cons c out)))))))))

(def (format-one-spec fmt start args)
  "Parse and format one %... specifier"
  (let ((flen (string-length fmt)))
    (let loop ((i (+ start 1)) (flags "") (width #f) (prec #f) (state 'flags))
      (if (>= i flen)
        (values "%" i args)
        (let ((c (string-ref fmt i)))
          (case state
            ((flags)
             (if (memq c '(#\- #\+ #\  #\0 #\#))
               (loop (+ i 1) (string-append flags (string c)) width prec 'flags)
               (loop i flags width prec 'width)))
            ((width)
             (cond
               ((char=? c #\*)
                ;; Width from argument
                (let ((w (inexact->exact (floor (awk->number (car args))))))
                  (set! args (cdr args))
                  (loop (+ i 1) flags w prec 'dot)))
               ((char-numeric? c)
                (let num-loop ((j i) (n 0))
                  (if (and (< j flen) (char-numeric? (string-ref fmt j)))
                    (num-loop (+ j 1) (+ (* n 10) (- (char->integer (string-ref fmt j))
                                                      (char->integer #\0))))
                    (loop j flags n prec 'dot))))
               (else (loop i flags width prec 'dot))))
            ((dot)
             (if (char=? c #\.)
               (loop (+ i 1) flags width prec 'prec)
               (loop i flags width prec 'spec)))
            ((prec)
             (cond
               ((char=? c #\*)
                (let ((p (inexact->exact (floor (awk->number (car args))))))
                  (set! args (cdr args))
                  (loop (+ i 1) flags width p 'spec)))
               ((char-numeric? c)
                (let num-loop ((j i) (n 0))
                  (if (and (< j flen) (char-numeric? (string-ref fmt j)))
                    (num-loop (+ j 1) (+ (* n 10) (- (char->integer (string-ref fmt j))
                                                      (char->integer #\0))))
                    (loop j flags width n 'spec))))
               (else (loop i flags width (or prec 0) 'spec))))
            ((spec)
             (let ((arg (if (null? args) (make-awk-uninit) (car args)))
                   (rest (if (null? args) '() (cdr args))))
               (values (do-format c arg flags (or width 0) prec)
                       (+ i 1) rest)))))))))

(def (do-format spec arg flags width prec)
  (let ((left-align? (string-contains flags "-"))
        (zero-pad? (string-contains flags "0"))
        (plus? (string-contains flags "+"))
        (space? (string-contains flags " ")))
    (case spec
      ((#\d #\i)
       (let* ((n (inexact->exact (truncate (awk->number arg))))
              (s (number->string n))
              (s (if (and plus? (>= n 0)) (string-append "+" s)
                     (if (and space? (>= n 0)) (string-append " " s) s))))
         (pad-string s width left-align? (and zero-pad? (not left-align?)))))
      ((#\o)
       (let* ((n (inexact->exact (truncate (awk->number arg))))
              (n (if (< n 0) (+ n (expt 2 32)) n))
              (s (number->string n 8)))
         (pad-string s width left-align? zero-pad?)))
      ((#\x #\X)
       (let* ((n (inexact->exact (truncate (awk->number arg))))
              (n (if (< n 0) (+ n (expt 2 32)) n))
              (s (number->string n 16))
              (s (if (char=? spec #\X) (string-upcase s) s)))
         (pad-string s width left-align? zero-pad?)))
      ((#\c)
       (let* ((n (awk->number arg))
              (ch (if (and (not (zero? n)) (= n (floor n)))
                    ;; Numeric argument: treat as character code
                    (string (integer->char (inexact->exact (floor n))))
                    ;; String argument: take first character
                    (let ((s (awk->string arg)))
                      (if (> (string-length s) 0)
                        (string (string-ref s 0))
                        " ")))))
         (pad-string ch width left-align? #f)))
      ((#\s)
       (let* ((s (awk->string arg))
              (s (if prec (substring s 0 (min prec (string-length s))) s)))
         (pad-string s width left-align? #f)))
      ((#\f)
       (let* ((n (awk->number arg))
              (prec (or prec 6))
              (s (format-float-f n prec)))
         (pad-string s width left-align? zero-pad?)))
      ((#\e #\E)
       (let* ((n (awk->number arg))
              (prec (or prec 6))
              (s (format-float-e n prec (char=? spec #\E))))
         (pad-string s width left-align? zero-pad?)))
      ((#\g #\G)
       (let* ((n (awk->number arg))
              (prec (or prec 6))
              (prec (max prec 1))
              (s (format-float-g n prec (char=? spec #\G))))
         (pad-string s width left-align? zero-pad?)))
      (else (string spec)))))

(def (pad-string s width left-align? zero-pad?)
  (let ((pad (max 0 (- width (string-length s)))))
    (if (= pad 0) s
      (if left-align?
        (string-append s (make-string pad #\space))
        (string-append (make-string pad (if zero-pad? #\0 #\space)) s)))))

;;; Float formatting

(def (format-float-f n prec)
  "Format float in %f style"
  (if (= prec 0)
    (number->string (inexact->exact (round n)))
    (let* ((factor (expt 10 prec))
           (rounded (/ (round (* n factor)) factor))
           (int-part (inexact->exact (truncate rounded)))
           (frac-part (abs (- rounded int-part)))
           (frac-digits (inexact->exact (round (* frac-part factor))))
           (frac-str (number->string frac-digits))
           (frac-str (string-append (make-string (max 0 (- prec (string-length frac-str))) #\0)
                                    frac-str))
           (sign (if (and (< n 0) (= int-part 0)) "-" "")))
      (string-append sign (number->string (abs int-part)) "." frac-str))))

(def (format-float-e n prec upper?)
  "Format float in %e style"
  (if (zero? n)
    (string-append "0." (make-string prec #\0) (if upper? "E+00" "e+00"))
    (let* ((sign (if (< n 0) "-" ""))
           (abs-n (abs n))
           (exp (inexact->exact (floor (/ (log abs-n) (log 10)))))
           (mantissa (/ abs-n (expt 10.0 exp)))
           ;; Adjust if mantissa rounds to 10
           (_ (when (>= mantissa 10.0)
                (set! mantissa (/ mantissa 10.0))
                (set! exp (+ exp 1))))
           (mant-str (format-float-f mantissa prec))
           (exp-sign (if (>= exp 0) "+" "-"))
           (exp-str (number->string (abs exp)))
           (exp-str (if (< (string-length exp-str) 2)
                      (string-append "0" exp-str) exp-str)))
      (string-append sign mant-str (if upper? "E" "e") exp-sign exp-str))))

(def (format-float-g n prec upper?)
  "Format float in %g style"
  (if (zero? n)
    "0"
    (let* ((abs-n (abs n))
           (exp (if (zero? abs-n) 0
                    (inexact->exact (floor (/ (log abs-n) (log 10))))))
           ;; Correct for floating-point imprecision
           (exp (if (>= abs-n (expt 10.0 (+ exp 1))) (+ exp 1) exp)))
      (if (and (>= exp -4) (< exp prec))
        ;; Use %f style, then strip trailing zeros
        (let ((s (format-float-f n (- prec exp 1))))
          (strip-trailing-zeros s))
        ;; Use %e style, then strip trailing zeros
        (let ((s (format-float-e n (- prec 1) upper?)))
          (strip-trailing-zeros-e s))))))

(def (strip-trailing-zeros s)
  (if (string-contains s ".")
    (let loop ((i (- (string-length s) 1)))
      (cond
        ((char=? (string-ref s i) #\0) (loop (- i 1)))
        ((char=? (string-ref s i) #\.) (substring s 0 i))
        (else (substring s 0 (+ i 1)))))
    s))

(def (strip-trailing-zeros-e s)
  ;; Find the 'e' or 'E', strip zeros before it
  (let ((epos (or (string-contains s "e") (string-contains s "E"))))
    (if epos
      (let ((before (substring s 0 epos))
            (after (substring s epos (string-length s))))
        (string-append (strip-trailing-zeros before) after))
      (strip-trailing-zeros s))))
